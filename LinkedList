Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
Example 2:


Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
 
 
 
 /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode temphead = head;
        int count = 0;
    while(head!=null){
        head = head.next;
        count++;
    }
    count = count/2;
    count = count+1;
    head = temphead;
    for(int i = 1; i<count;i++){
        head = head.next;
    }
        return head;
    }
}



1290. Convert Binary Number in a Linked List to Integer
Easy
3.7K
147
Companies
Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.

The most significant bit is at the head of the linked list.

 

Example 1:


Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
Example 2:

Input: head = [0]
Output: 0
 

Constraints:

The Linked List is not empty.
Number of nodes will not exceed 30.
Each node's value is either 0 or 1.
Accepted
386.2K
Submissions
471.2K
Acceptance Rate
81.9%




/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
import java.util.*;
import java.lang.*;
// import java.io.*;


class Solution {
    public int getDecimalValue(ListNode head) {
       
        String s = new String();
        ListNode temp = head;
        while(head!=null){
            s = s + head.val;
            head = head.next;
        }
        StringBuffer s1 = new StringBuffer(s);
        s1.reverse();
        String ans = s1.toString();
        int ret = 0; 
        int tem = 0;
        for(int i = 0; i<ans.length(); i++){
            tem = 0;
            if(ans.charAt(i)=='1'){
                tem = (int)Math.pow(2, i);
                ret = ret + tem;
            }
        }
        return ret;
    }
}



206. Reverse Linked List
Easy
18K
329
Companies
Given the head of a singly linked list, reverse the list, and return the reversed list.

 

Example 1:


Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:


Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []
 

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000
 

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?




/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) return head;
        ListNode ans = head;
        ListNode temphead =  head;
        ArrayList<Integer> AL = new ArrayList<Integer>();
        while(head!=null){
            AL.add(head.val);
            head = head.next;
        }
        Collections.reverse(AL);
       for(int i=0; i<AL.size();i++){
           ans.val = AL.get(i);
           ans = ans.next;
       }
       return temphead;
    }
}


21. Merge Two Sorted Lists
Easy
18.4K
1.7K
Companies
You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

 

Example 1:


Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
Example 2:

Input: list1 = [], list2 = []
Output: []
Example 3:

Input: list1 = [], list2 = [0]
Output: [0]
 

Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.



/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(((list1==null) && (list2==null)) || ((list1!=null && list2 == null))) return list1;
        if((list1 == null) && (list2!=null)) return list2;
        ListNode temphead = list1;
        ListNode ans = list1;
        ArrayList<Integer> AL = new  ArrayList<>();
        if(list1.next==null){}
        else{
        while(list1.next!=null){
            AL.add(list1.val);
            list1 = list1.next;
        }
        }
        AL.add(list1.val);
        list1.next = list2;
        while(list2!=null){
            AL.add(list2.val);
            list2 = list2.next;
        }
        Collections.sort(AL);
        for(int i=0;i<AL.size();i++){
            temphead.val = AL.get(i);
            temphead = temphead.next;
        }
        return ans;
    }
}


















